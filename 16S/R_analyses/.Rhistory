df$prev<-factor(df$prev,
levels = c("5% in 10 studies (212 feat.)",
"10% in 10 studies (154 feat.)",
"20% in 10 studies (109 feat.)",
"30% in 10 studies (85 feat.)"))
(g<-ggplot(df, aes(prev, AUC, fill=norm)) +
geom_boxplot() +
facet_wrap(~ML, nrow = 1) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90,
hjust=0.95,
vjust=0.2)) +
scale_fill_manual(values = c("#A669EE", "#CC79A7")) +
xlab("Feature filtrations")+
labs(fill = "Normalization")+
theme(axis.text = element_text(size = 10),
axis.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.title = element_text(size = 14),
strip.text = element_text(size = 9.5)))
# ggsave(filename = "~/Documents/EMBL_ML_PD/16S/R_analyses/Figures/AUC_PrevMLnorm.jpg",
#        plot = g,
#        device = "jpg",
#        width = 8.5,
#        height = 6)
# Chunk 5
perf_sing_log<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/Single_5per_log.rds")
#take only 5%
perf_sing_log<-subset(perf_sing_log, prev == "5% in 10 std")
perf_sing_log$batch<-rep("Not corrected", nrow(perf_sing_log))
# format to merge with the other
perf_log<-data.frame(
training.data = perf_sing_log$study,
testing.data  = perf_sing_log$study,
AUC = perf_sing_log$AUC,
ML = perf_sing_log$ML,
norm = perf_sing_log$norm
)
csv<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc.rds")
df_comb<-rbind.data.frame(perf_log, csv)
df_comb.p<-df_comb
# saveRDS(df_comb.p, "~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/df.com.rds") # need to ahve this to take the mean value for plotting right colours
df_comb$AUC<-as.numeric(df_comb$AUC)
df_comb$AUC<-round(df_comb$AUC, digits = 2) *100
df.auc<-subset(df_comb, AUC > 85 | AUC < 50)
df.diag<-df_comb[1:102,]
(r<-ggplot(df_comb, aes(x =  testing.data,training.data,  fill = AUC)) +
geom_tile(color = "black") +
geom_text(aes(label = AUC), color = "black", size = 4) +
geom_text(data = df.auc, mapping = aes(label = AUC), color = "white", size = 4) +
coord_fixed() +
scale_fill_viridis_c(option = "H",
breaks=c(50,70,100),
limits=c(40,100))+
theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust=0.95,vjust=0.2),
strip.text = element_text(size = 12),
axis.text = element_text(size = 12),
axis.title = element_text(size = 14),
legend.text = element_text(size = 12),
legend.title = element_text(size = 14),
legend.position = "right") +
facet_wrap(~ ML)+
geom_tile(data = df.diag, fill = NA, color = "white", linewidth = 2)+
facet_wrap(~ ML) +
xlab("Test data") +
ylab("Training data"))
# ggsave(plot = r, filename = "~/Documents/EMBL_ML_PD/16S/R_analyses//Figures/CSV_5perc_log.svg", device = "svg", width = 21, height = 18)
# ggsave(plot = r, filename = "~/Documents/EMBL_ML_PD/16S/R_analyses//Figures/CSV_5perc_log.jpg", device = "jpg", width = 21, height = 18)
#############################
# do clustering
###########################3
library(heatmaply)
library(dendextend)
df.comb.csv.ridge<-subset(df_comb, ML == "ridge")
df<-df.comb.csv.ridge %>%
select(-ML, -norm) %>%
pivot_wider(names_from = testing.data, values_from = AUC) %>%
as.data.frame()
rownames(df)<-df$training.data
df<-df[,-1]
##############
# cluster both
##############
# Compute hierarchical clustering
hc_rows <- hclust(dist(df))
dend_rows <- as.dendrogram(hc_rows)
# Plot dendrogram
plot(dend_rows, main = "Dendrogram with Labels", xlab = "Players", horiz = TRUE)# perform hierarchical clustering
rowclus <- hclust(dist( df ))    #cluster the rows
colclus <- hclust(dist( t(df) )) #cluster the columns
# bring the data.frame into a from easily usable by ggplot
hm <- hmReady(df, colclus=colclus, rowclus=rowclus)
names(hm)<-c("training.set", "testing.set", "AUC", "x", "y")
ggplot(data=hm, aes(x=x, y=y, fill=AUC)) +
geom_tile() +                      #heatmap
scale_fill_viridis_c(option = "H",
breaks=c(50,70,100),
limits=c(40,100))+
geom_text(aes(label = AUC), color = "black", size = 4) +
geom_dendro(colclus, ylim=c(17.5, 20)) +                             #upper dendrogram
geom_dendro(rowclus, xlim=c(17.5, 19), pointing="side") +             #side dendrogram
theme_hm() +
labs("Clustering of CSV AUCs for ridge") +
xlab("test.set") +
ylab("training.set")
##############
# cluster rows
##############
# perform hierarchical clustering
rowclus <- hclust(dist( df ))    #cluster the rows
# bring the data.frame into a from easily usable by ggplot
hm <- hmReady(df, rowclus=rowclus)
names(hm)<-c("training.set", "testing.set", "AUC", "x", "y")
ggplot(data=hm, aes(x=x, y=y, fill=AUC)) +
geom_tile() +                      #heatmap
scale_fill_viridis_c(option = "H",
breaks=c(50,70,100),
limits=c(40,100))+
geom_text(aes(label = AUC), color = "black", size = 4) +
geom_dendro(colclus, ylim=c(0, 0), failsafe = T) +  # thisis just to add the names
geom_dendro(rowclus, xlim=c(17.5, 19), pointing="side") +             #side dendrogram
theme_hm()+                                                          #design
theme(axis.title=element_blank())
############################
# network
#########################
# Load required libraries
df<-df.comb.csv.ridge
# Load required libraries
library(igraph)
library(RColorBrewer)
# Find unique IDs
unique_ids <- unique(c(df$training.data, df$testing.data))
# Initialize a dataframe to store node information
node_df <- data.frame(id = unique_ids, self_auc = rep(0, length(unique_ids)))
# Calculate self-AUC values for each node
for (i in 1:length(unique_ids)) {
node_name <- unique_ids[i]
self_auc <- mean(as.numeric(df[(df$training.data == node_name & df$testing.data == node_name) | (df$testing.data == node_name & df$training.data == node_name), "AUC"]))
node_df$self_auc[i] <- self_auc
}
# Create an empty graph
g <- graph.empty(n = nrow(node_df), directed = FALSE)
# Add vertices
V(g)$name <- node_df$id
# Define node colors using a Brewer palette based on self-AUC values
pal <- brewer.pal(n = 9, name = "YlOrRd")  # Choose a palette from Brewer
node_colors <- colorRampPalette(pal)(length(unique_ids))
V(g)$color <- node_colors[cut(node_df$self_auc, breaks = length(pal), labels = FALSE)]
# Add edges based on AUC threshold
threshold <- 60  # Adjust this threshold as needed
for (i in 1:nrow(df)) {
if (as.numeric(df[i, "AUC"]) > threshold) {
from_vertex <- which(V(g)$name == df[i, "training.data"])
to_vertex <- which(V(g)$name == df[i, "testing.data"])
if (!is.na(from_vertex) && !is.na(to_vertex) && from_vertex != to_vertex) {
g <- add_edges(g, c(from_vertex, to_vertex))
}
}
}
# Remove self-loops
g <- simplify(g, remove.multiple = FALSE, remove.loops = TRUE)
# Plot the network
plot(g, layout = layout_with_fr(g), vertex.label.family = "Arial", vertex.label.color = "black", vertex.label.cex = 1.2, vertex.label.font = 2)
subset(df, training.data == "Hopfner" | testing.data == "Hopfner")
# Chunk 6
rar2<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc_rar2.rds")
csv<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc.rds")
rar2$rar<-"Rarefied at 2000"
csv$rar<-"Not rarefied"
all(rar2$training.data  == csv$training.data )
all(rar2$ML == csv$ML)
df.rar2<-data.frame(not_rar=csv$AUC,
rar=rar2$AUC,
ML = csv$ML,
study = csv$training.data )
df.rar2$not_rar<-as.numeric(df.rar2$not_rar)
df.rar2$rar<-as.numeric(df.rar2$rar)
# format for t-test test
l_df.rar<-split(df.rar2, f = as.factor(df.rar2$ML))
l_df.rar.w<-lapply(l_df.rar, function(x) t.test(Pair(not_rar, rar) ~ 1, data = x, var.equal = F))
l_df.rar.w
# check averages
lapply(l_df.rar, function(x) x %>%
summarise(average_NOTrar = mean(not_rar),
stdev_NOTrar = sd(not_rar),
average_rar = mean(rar),
stdev_rar = sd(rar)))
tmp<-df.rar2 %>%
group_by(ML) %>%
summarise(cor = cor.test(not_rar, rar, use = "all.obs")$estimate,
pvalue = cor.test(not_rar, rar, use = "all.obs")$p.value)
g<-ggplot(df.rar2, aes(not_rar, rar)) +
geom_point(size = 4, pch = 21,  stroke = 1, alpha = 0.6) +
geom_abline(intercept = 0, slope = 1) +
facet_wrap(~ML) +
theme_bw() +
xlab("Not rarefied") +
ylab("Rarefied") +
geom_text(data = tmp,
aes(label = paste(" Correlation coefficient: ",
round(cor, 1),
"\n",
"log10(p-value): ",
round(log10(pvalue),1))),
x = 0.25, y = 0.78, hjust = 0, vjust = 0, size = 4)
g
# ggsave(filename = "~/Documents/EMBL_ML_PD/16S/R_analyses/Figures/Rarefied_vs_notRarefied.jpeg",
#        width = 10, height = 6)
# df.rar<-rbind.data.frame(rar2, csv)
# df.rar$AUC<-as.numeric(df.rar$AUC)
# g<-ggplot(df.rar, aes(rar, AUC)) +
#   geom_boxplot() +
#   facet_wrap(~ML) +
#   xlab("") +
#   ylab("AUC") +
#   theme_bw()
# g
# ggsave(filename = "~/Documents/EMBL_ML_PD/16S/R_analyses//Figures/BoxPlor_Rarefied_vs_notRarefied.svg", width = 8, height = 4)
# Chunk 7
per.mean<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc_mean.rds")
per.mean$batch<-rep("Mean", nrow(per.mean))
per.mmmup<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc_MMuphin.rds")
per.mmmup$batch<-rep("MMuphin", nrow(per.mmmup))
per.rA<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc_ratioA.rds")
per.rA$batch<-rep("ratioA", nrow(per.rA))
per.rG<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc_ratioG.rds")
per.rG$batch<-rep("ratioG", nrow(per.rG))
per<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/CSV_5perc_Log_df_auc.rds")
per$batch<- rep("Not corrected", nrow(per))
perf<-rbind.data.frame(per,
per.mean,
per.mmmup,
per.rA,
per.rG)
perf$batch<-as.factor(perf$batch)
perf$batch<-relevel(perf$batch, ref = "Not corrected")
perf$AUC<-as.numeric(perf$AUC)
g<-ggplot(perf, aes(batch, AUC)) +
geom_boxplot() +
facet_wrap(~ML) +
xlab("Batch correction") +
ylab("AUC") +
theme_bw() +
theme(axis.text.x=element_text(size=8, angle=90,hjust=0.95,vjust=0.2))
g
ggsave(filename = "~/Documents/EMBL_ML_PD/16S/R_analyses/Figures/Batch_correction.CSV.jpeg", width = 8, height = 4)
# test sign of differences
perf %>%
group_by(ML) %>%
summarise(anova.pvalue = anova(aov(as.numeric(AUC)~batch))$`Pr(>F)`[1])
perf %>%
group_by(ML) %>%
summarise(anova.pvalue = anova(aov(as.numeric(AUC)~batch)))
perf$AUC<-as.numeric(perf$AUC)
perf$comb<-paste0(perf$training.data, "_", perf$testing.data)
l.perf<-split(perf, as.factor(perf$ML))
#
# l.aov<-l.perf
# for(i in 1:length(l.perf)){
#   print(unique(l.perf[[i]]$ML))
#   print(summary(aov(as.numeric(l.perf[[i]]$AUC)~l.perf[[i]]$batch)))
#   l.aov[[i]]<-aov(as.numeric(l.perf[[i]]$AUC)~l.perf[[i]]$batch)
# }
#
# l.t<-l.aov
# for(i in 1:length(l.aov)){
#   print(names(l.aov)[i])
#   x <-TukeyHSD(l.aov[[i]])
#     l.t[[i]]<-x$`l.perf[[i]]$batch` %>% as.data.frame()
# }
#
# df.t<-do.call(rbind, l.t)
# df.tukey<-data.frame(ML = gsub("[.].*", "", row.names(df.t)),
#                      comparisons = gsub(".*[.]", "", row.names(df.t)),
#                      diff = df.t$diff,
#                      CI.lower = df.t$lwr,
#                      CI.upper = df.t$upr,
#                      p.value.adjust = df.t$`p adj`)
#
#
# # write.table(x = df.tukey,
# #             file = "~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/Tukey.Batch.Aug24.txt",
# #             col.names = T,
# #             row.names = F,
# #             quote = F,
# #             sep = "\t")
# perf %>%
#   group_by(ML, batch) %>%
#   summarise(mean = mean(AUC),
#             stdev = sd(AUC)) %>%
#   print(n =50)
# ranodm effect
library(emmeans)
l.aov<-l.perf
for(i in 1:length(l.perf)){
print(unique(l.perf[[i]]$ML))
print(summary(nlme::lme(AUC~batch, data = l.perf[[i]], random = ~ 1 | comb)))
l.aov[[i]]<-nlme::lme(AUC~batch, data = l.perf[[i]], random = ~ 1 | comb)
}
l.t1<-l.aov
for(i in 1:length(l.aov)){
print(names(l.aov)[i])
x <-emmeans::emmeans(l.aov[[i]], pairwise ~ batch, adjust = "fdr")
l.t1[[i]]<-x$contrasts %>% as.data.frame()
}
# mod<-nlme::lme(AUC~batch, data = l.perf[[i]], random = ~ 1 | comb)
# mod2<-lme4::lmer(AUC~batch+ (1 | comb), data = l.perf[[i]])
# mod3<-lm(AUC~batch, data = l.perf[[i]])
#
# summary(mod)
# emm<-emmeans::emmeans(mod, pairwise ~ batch)
# performance::check_model(mod)
# performance::icc(mod)
#
# summary(mod2)
# performance::check_model(mod2)
# smm2<-emmeans::emmeans(mod2, pairwise ~ batch)
# performance::icc(mod2)
#
# summary(mod3)
# emm3<-emmeans::emmeans(mod3, pairwise ~ batch)
# performance::check_model(mod3)
# performance::icc(mod3)
#
#
#
# anova(mod, mod2)
# anova(mod, mod3)
#
# emmip(emm, ~ batch)
# emmip(emm2, ~ batch | comp)
# emmip(emm3, ~ batch)
df.t<-do.call(rbind, l.t1)
df.t$ML.method<-c(rep("ENET", nrow(df.t)/6),
rep("LASSO", nrow(df.t)/6),
rep("LASSO-LibLinear", nrow(df.t)/6),
rep("Random Forest", nrow(df.t)/6),
rep("Ridge regression", nrow(df.t)/6),
rep("Ridge-LibLinear", nrow(df.t)/6))
# double check that this is correct
head(df.t)
l.t1$ENET
l.perf$ENET<-l.perf$enet[-c(1:10),]
l.perf$ENET<-l.perf$enet[-c(1:10),]
mod<-nlme::lme(AUC~batch, data =l.perf$enet, random = ~ 1 | comb)
mod1<-lm(AUC~batch, data =l.perf$enet)
emmeans(mod, pairwise ~ batch)
emmeans(mod1, pairwise ~ batch)
l.perf$enet<-l.perf$enet[-c(1:10),]
mod<-nlme::lme(AUC~batch, data =l.perf$enet, random = ~ 1 | comb)
mod1<-lm(AUC~batch, data =l.perf$enet)
emmeans(mod, pairwise ~ batch)
emmeans(mod1, pairwise ~ batch)
l.perf[[i]]
# Chunk 1: setup
list.of.packages <- c("dplyr", "BiocManager", "ggplot2",  "tidyverse","ggrepel", "RColorBrewer")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
if (!requireNamespace("BiocManager", quietly = TRUE)){
install.packages("BiocManager")}
list.of.bioc <- c("phyloseq", "grDevices")
new.packages <- list.of.bioc[!(list.of.bioc %in% installed.packages()[,"Package"])]
if(length(new.packages)) BiocManager::install(new.packages)
library(phyloseq)
library(RColorBrewer)
library(ggpubr)
library(vegan)
library(dplyr)
library(tidyverse)
library(ggrepel)
library(SIAMCAT)
# load my function to run siamca
source("~/Documents/EMBL_ML_PD//R_analyses_metaG/Pre_processing_functions/Model_coefficient_extraction.r")
set.seed(56987)
# Chunk 2
meta<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/meta.rds")
meta$Study_2<-as.character(meta$Study_2)
# Chunk 3
load("~/Documents/EMBL_ML_PD/16S/R_analyses/RData/16S_Sinlge_5perc_log.RData")
lridge<-coefficient.extraction(studies = unique(meta$Study_2) %>% as.character(),
list.models = ridge_5x10,
model.parallel = T,
string.to.add = "log_ridge_5x10",
select = "mean.weight")
lridge<-lapply(lridge, function(x) mutate(x, relative.weigths= x$overall.average / sum(abs(x$overall.average))))
lapply(lridge, dim) # different taxa number in different studies, results of taxa filtrations.
df1<-do.call(rbind, lridge) %>% as.data.frame()
# Chunk 4
nrow(df1)
# check if there are coeff == 0
subset(df1, relative.weigths  == 0)
# There are no coeff == 0. This is correct
# add a dummy variable used for formatting
df1$dummy<-rep(1, nrow(df1))
# add another dummy variable to indicate if it is pos or neg
df1$pos.neg<-ifelse(df1$relative.weigths > 0, "POS", "NEG") %>% as.factor()
# make a df with average and std of relative.weights
taxa.weights<-df1 %>%
group_by(taxa) %>%
summarise(average = mean(relative.weigths),
stdev = sd(relative.weigths)) %>%
as.data.frame()
taxa.weights<-taxa.weights[order(taxa.weights$average, decreasing = T),]
taxa.weights$dir<-ifelse(taxa.weights$average > 0 , "HC", "PD")
# saveRDS(taxa.weights, "~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/Ridge_taxa.weights.rds")
# make df indicating pos and negative counts
df.pos.neg<-df1 %>%
group_by(taxa, pos.neg) %>%
summarise(count = sum(dummy)) %>%
as.data.frame()
df.pos.neg2<-df1 %>%
group_by(taxa, pos.neg) %>%
summarise(dummy2 = n()) %>%
as.data.frame()
df.pos.neg<-df.pos.neg[,-1*ncol(df.pos.neg)]
df.pos.neg2<-df.pos.neg2[,-1*ncol(df.pos.neg2)]
all.equal(df.pos.neg,df.pos.neg2)
# add average to df.pos.neg
for(i in 1:nrow(df.pos.neg)){
df.pos.neg$average[i]<-taxa.weights[taxa.weights$taxa == df.pos.neg$taxa[i], "average"]
df.pos.neg$stdev[i]<-taxa.weights[taxa.weights$taxa == df.pos.neg$taxa[i], "stdev"]
}
# saveRDS(df.pos.neg, "~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/Ridge_df.pos.neg.rds")
# df.pos.neg<-readRDS("~/Documents/EMBL_ML_PD/16S/R_analyses/RDS/Ridge_df.pos.neg.rds")
df<-reshape2::dcast(df1,
study ~ taxa, value.var = "relative.weigths")
# format df
df[is.na(df)]<-0
rownames(df)<-df$study
df<-df[,-1]
dist<-vegdist(df, method = "canberra")
pc<-metaMDS(dist)
# check stress
stressplot(pc)
# looks acceptable
d<-pc$points[] %>%
as.data.frame()
d$study<-gsub("_.*", "", rownames(d))
d$var<-rownames(d)
#format the meta
meta.short<-meta[!duplicated(meta$Study_2),]
# change petrov with Europe
meta.short[1,3]<-"Europe"
d<-d[order(d$study),]
meta.short<-meta.short[order(meta.short$Study_2),]
d[which(d$study == "Heintz"),3]<-"Heintz_Bushart"
all(meta.short$Study_2 == d$study)
# merge
d.m<-cbind.data.frame(d, meta.short)
adonis2(dist~Continent, data =  meta.short)
nb.cols <- 24
mycolors <- colorRampPalette(brewer.pal(8, "Set2"))(nb.cols)
# adjust study names
d.m$Study_2<-as.character(d.m$Study_2)
d.m$Study_2[d.m$Study_2 == "Aho"]<-"Aho_2019"
d.m$Study_2[d.m$Study_2 == "Petrov"]<-"Petrov_2017"
d.m$Study_2[d.m$Study_2 == "Keshavarzian"]<-"Keshavarzian_2015"
d.m$Study_2[d.m$Study_2 == "Zhang"]<-"Zhang_2020"
d.m$Study_2[d.m$Study_2 == "Nishiwaki"]<-"Nishiwaki_2020"
d.m$Study_2[d.m$Study_2 == "Hopfner"]<-"Hopfner_2017"
d.m$Study_2[d.m$Study_2 == "Weis"]<-"Weis_2019"
d.m$Study_2[d.m$Study_2 == "Cirstea"]<-"Cirstea_2020"
d.m$Study_2[d.m$Study_2 == "Tan"]<-"Tan_2021"
d.m$Study_2[d.m$Study_2 == "Kenna"]<-"Kenna_2021"
d.m$Study_2[d.m$Study_2 == "Wallen251"]<-"Wallen251_2021"
d.m$Study_2[d.m$Study_2 == "Wallen151"]<-"Wallen151_2021"
d.m$Study_2[d.m$Study_2 == "Jo"]<-"Jo_2022"
d.m$Study_2[d.m$Study_2 == "Lubomski"]<-"Lubomski_2022"
d.m$Study_2[d.m$Study_2 == "Heintz_Bushart"]<-"Heintz_Buschart_2017"
d.m$Study_2[d.m$Study_2 == "Qian"]<-"Qian_2018"
d.m$Study_2[d.m$Study_2 == "Pietrucci"]<-"Pietrucci_2019"
g16<-ggplot(d.m, aes(MDS1, MDS2)) +
geom_point(aes(color = Study_2), size = 5, stroke = 3, pch = 21) +
scale_color_manual(values = mycolors) +
geom_point(aes(fill = Continent), size = 5, stroke = 0, pch = 21) +
scale_fill_manual(values = c("#8C510A", "#F6E8C3", "#C7EAE5", "#01665E" )) +
theme_bw() +
theme(legend.text = element_text(size = 16),
legend.title = element_text(size =18),
axis.title = element_text(size =16),
axis.text = element_blank(),
plot.caption = element_text(size =16)) +
labs(color = "Study")
# load metaG
d.mg<-readRDS("~/Documents/EMBL_ML_PD/metaG/R_analyses/Taxonomy/RDS/coeff_nmds.rds")
nb.cols <- 18
mycolors <- colorRampPalette(brewer.pal(8, "Set2"))(nb.cols)
d.mg$study<-gsub("_log.*", "", d.mg$var)
g.smg<-ggplot(d.mg, aes(MDS1, MDS2)) +
geom_point(aes(color = study), size = 5, stroke = 3, pch = 21) +
scale_color_manual(values = mycolors) +
geom_point(aes(fill = Continent), size = 5, stroke = 0, pch = 21) +
scale_fill_manual(values = c("#8C510A", "#F6E8C3", "#C7EAE5", "#01665E" )) +
theme_bw() +
theme(legend.text = element_text(size = 16),
legend.title = element_text(size =18),
axis.title = element_text(size =16),
axis.text = element_blank(),
plot.caption = element_text(size =16)) +
labs(color = "Study") + # values were calculated in the metaG script
guides(fill = "none")
coeff<-cowplot::plot_grid(g16, g.smg,
ncol = 2,
align = "h",
axis = "bl",
rel_widths =c(1.1,1),
rel_heights = c(1,1),
labels = c("auto"),
label_size = 20)
coeff
